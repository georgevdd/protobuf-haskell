#summary Basics of Protocol Buffers in Haskell

= Protocol Buffer Basics: Haskell =

This tutorial provides a basic Haskell programmer's introduction to working with protocol buffers.  By walking through creating a simple example application, it shows you how to
  * Define message formats in a `.proto` file.
  * Use the protocol buffer compiler.
  * Use the Haskell protocol buffer API to write and read messages.
This isn't a comprehensive guide to using protocol buffers in Haskell. For more detailed reference information, see the [http://code.google.com/apis/protocolbuffers/docs/proto.html Protocol Buffer Language Guide], the [http://hackage.haskell.org/package/protocol-buffers Haskell API Reference], the (forthcoming) Haskell Generated Code Guide, and the [http://code.google.com/apis/protocolbuffers/docs/encoding.html Encoding Reference].

== Why Use Protocol Buffers? ==

The example we're going to use is a very simple "address book" application that can read and write people's contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.

Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data such as this. The [http://code.google.com/apis/protocolbuffers/docs/overview.html Protocol Buffers Overview] compares their advantages to those of other approaches.

With protocol buffers, you write a `.proto` description of the data structure you wish to store. From that, the protocol buffer compiler creates code that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated code provides representations for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.

== Where to Find the Example Code ==

== Defining Your Protocol Format ==

To create your address book application, you'll need to start with a `.proto` file. The definitions in a `.proto` file are simple: you add a message for each data structure you want to serialize, then specify a name and a type for each field in the message. Here is the `.proto` file that defines your messages, `addressbook.proto`.

{{{
package tutorial;

option java_package = "com.example.tutorial";
option java_outer_classname = "AddressBookProtos";

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}

message AddressBook {
  repeated Person person = 1;
}
}}}

As you can see, the syntax is similar to C++ or Java. Let's go through each part of the file and see what it does.
The `.proto` file starts with a package declaration, which helps to prevent naming conflicts between different projects. In Haskell, the package name is used to form the hierarchical prefix of each generated module, unless you have explicitly specified a `java_package`, as we have here. Even if you do provide a `java_package`, you should still define a normal `package` as well to avoid name collisions in the Protocol Buffers name space as well as in other languages.

TODO: check this paragraph. After the package declaration, you can see two options that are Java-related but that are used by the Haskell code generator too: `java_package` and `java_outer_classname`. `java_package` specifies in what Java package name your generated classes should live. If you don't specify this explicitly, it simply matches the package name given by the package declaration, but these names usually aren't appropriate Java package names (since they usually don't start with a domain name). The `java_outer_classname` option defines the class name which should contain all of the classes in this file. If you don't give a `java_outer_classname` explicitly, it will be generated by converting the file name to camel case. For example, "my_proto.proto" would, by default, use "MyProto" as the outer class name.

Next, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including `bool`, `int32`, `float`, `double`, and `string`. You can also add further structure to your messages by using other message types as field types – in the above example the `Person` message contains `PhoneNumber` messages, while the `AddressBook` message contains `Person` messages. You can even define message types nested inside other messages – as you can see, the `PhoneNumber` type is defined inside `Person`. You can also define `enum` types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of `MOBILE`, `HOME`, or `WORK`.

The " = 1", " = 2" markers on each element identify the unique "tag" that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for this optimization.

Each field must be annotated with one of the following modifiers:
  * `required`: a value for the field must be provided, otherwise the message will be considered "uninitialized". Trying to build an uninitialized message will (TODO: fail how?). Parsing an uninitialized message will (TODO: fail how?). Other than this, a required field behaves exactly like an optional field.
  * `optional`: the field may or may not be set. If an optional field value isn't set, a default value is used. For simple types, you can specify your own default value, as we've done for the phone number `type` in the example. Otherwise, a system default is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the "default instance" or "prototype" of the message, which has none of its fields set. Calling the accessor to get the value of an optional (or required) field which has not been explicitly set always returns that field's default value.
  * `repeated`: the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays.

==== Required Is Forever ====
You should be very careful about marking fields as `required`. If at some point you wish to stop writing or sending a required field, it will be problematic to change the field to an optional field – old readers will consider messages without this field to be incomplete and may reject or drop them unintentionally. You should consider writing application-specific custom validation routines for your buffers instead. Some engineers at Google have come to the conclusion that using `required` does more harm than good; they prefer to use only `optional` and `repeated`. However, this view is not universal.

You'll find a complete guide to writing `.proto` files – including all the possible field types – in the [http://code.google.com/apis/protocolbuffers/docs/proto.html Protocol Buffer Language Guide].

== Compiling Your Protocol Buffers ==

== The Protocol Buffer API ==

== Writing a Message ==

== Reading a Message ==

== Extending a Protocol Buffer ==

== Optimization Tips ==

== Advanced Usage ==